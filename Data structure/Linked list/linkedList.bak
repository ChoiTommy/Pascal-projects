program linkedList;
const size = 10;
      null = -1;

type
    nodeType = record
                    next : integer;
                    data : string;
               end;
    listType = record
                    list : array[1..size] of nodeType; //**NODE TYPE */
                    head : Integer;
               end;

var l : listType;
    response : string;

procedure init(var l : listType);
var i : Integer;
begin
    for i := 1 to size do
    begin
        l.list[i].data := '';
        l.list[i].next := Null; //** -1 means end of list */
    end;
    l.head := Null;
end;

function searchFreeNode(l : listType):Integer;
(*Search for position of free node*)
(*return null for full linked list*)
var i : Integer;
begin
    i := 1;
    while (i <= size) and (l.list[i].data <> '') do //**MUST PUT (i <= size) FIRST because [i] may overflow */
        i := i + 1;
    if i > size then
        searchFreeNode := Null
    else
        searchFreeNode := i;
end;

procedure insertBegin(data : string; var l : listType);
var freepos : Integer;
begin
    freepos := searchFreeNode(l); //**find empty node */
    if freepos = null then
        WriteLn('Error') //**NO FREE POSITION to insert data*/
    else
    begin
        l.list[freepos].data := data;
        l.list[freepos].next := l.head;
        l.head := freepos;
    end;
end;

{function search(x : string; l: listType; p : integer): Integer; //p := l.head
begin
    if (p<>Null) and (l.list[p].data <> data) then
        search := search(l.list[p], l, l.list[p].next)
    else
        search := p;
end;}

function search(data : string; l: listType): Integer;
var p : Integer;
begin
    p := l.head;
    while (p<>Null) and (l.list[p].data <> data) do //**P<>null must be put first */
        p := l.list[p].next; //**advance to next pointer, make use of next */
    search := p;
end;

procedure insertAfter(after, data : string; var l : listType);
var freepos, afterpos : Integer;
begin
    freepos := searchFreeNode(l);
    if freepos = null then
        WriteLn('Error') //**NO FREE POSITION to insert data*/
    else
    begin
        afterpos := search(after, l);
        {set the next of new data to one after}
        l.list[freepos].next := l.list[afterpos].next;
        {store data into free node}
        l.list[freepos].data := data;
        {update next of after to the pos of the new node}
        l.list[afterpos].next := freepos;
    end;
end;

begin
    init(l);
    repeat
        writeln('1. Insert at the beginning of the linked list.');
        WriteLn('2. Insert to a certain item.');
        WriteLn('3. Delete a node.');
        WriteLn('4. Search for a node.');
        readln(response);
        if response = 1 then
        begin
        end
        else if response = 2 then
        begin
        end;
    until upcase(response) = 'EXIT';
end.